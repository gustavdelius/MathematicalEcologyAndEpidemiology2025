# Discrete-time population models {#sec-discrete}

So far we have assumed that the rate of change of the population number has no explicit time dependence. However births and also deaths often happen on an annual cycle. Many fish have their spawning season in the spring, and many birds breed in the summer and annual plants produce their seed and then die in winter. In this case, the rate of change of the population number is not constant, but depends on the time of the year. We can model this by introducing a time dependence in the birth and death rates. However this will lead to equations that will be difficult to analyse. Instead we can give up on the idea of modelling the population numbers continuously through time and instead only follow how the population changes from year to year. 

So we will use models of the form
$$
N_{t+1} = f(N_t)
$$ {#eq-discrete_time}
where $N_t$ is the population number at time $t$ and $f$ is some function. Time $t$ now takes on only integer values, and the population number is only defined at these times. This is called a discrete-time model. Given the initial population number $N_0$, we can calculate the population number at any future time $t$ by iterating the function $f$: $N_1 = f(N_0)$, $N_2 = f(N_1)=f(f(N_0)),\ldots N_t = f(f(\ldots f(N_0)\ldots))$.


## Learning Objectives {.unnumbered}

After completing this chapter, you should be able to:

1. **Mathematical Modeling**
   - Write down difference equations for population dynamics
   - Identify and interpret key parameters in discrete-time models
   - Solve basic discrete-time population models

2. **Model Analysis**
   - Find fixed points of discrete-time models
   - Determine stability using linear analysis and cobweb diagrams
   - Interpret cobweb diagrams
   - Predict long-term behavior of populations

3. **Bifurcations**
   - Identify different types of bifurcations in discrete-time models
   - Analyze how model behavior changes at bifurcation points
   - Understand period-doubling bifurcations unique to discrete systems

4. **Applications**
   - Compare and contrast different discrete-time population models
   - Analyze harvesting strategies in discrete-time models
   - Understand critical depensation in discrete systems
   
## Key Ecological Concepts {.unnumbered}

Before diving into the mathematical models, let's clarify some ecological terminology:

- **Population**: A group of individuals of the same species living in a particular area
- **Carrying capacity**: The maximum sustainable population size in a given environment
- **Critical depensation**: A threshold effect where populations below a certain size tend to decline to extinction
- **Density dependence**: How population growth rates change with population size
- **Seasonal reproduction**: When breeding occurs at specific times of year rather than continuously

These concepts will help explain why we choose particular mathematical forms for our models.

## Exponential model

Just as we started with the exponential model in @sec-continuous, we begin here with the simplest discrete-time model
$$
N_{t+1} = R N_t
$$ {#eq-discrete_exponential}
where $R>0$ is the growth factor. This is the discrete-time version of the continuous-time exponential model. The solution to this equation is
$$
N_t = N_0 R^t.
$$ {#eq-discrete_exponential_solution}
It is important to stress that $R$ is not a growth _rate_ but a dimensionless growth factor. Comparing the discrete-time solution to the continuous-time solution $N(t)=N_0\exp(rt)$ we see that they agree at integer times $t$ if we measure time in years and set 
$$
R=\exp(r \cdot 1\text{ year}).
$$ {#eq-discrete_continuous_relation}
If you are confused by the units, remember that the exponential function is dimensionless, so the argument of the exponential function must be dimensionless. We need the extra factor of 1 year because $r$ is a rate and has dimension 1/time.

The population number grows exponentially with time if $R>1$ and declines exponentially if $R<1$. To get more realistic models we again need to introduce a limited carrying capacity.

::: {#exr-aer}
#### AER
You may be familiar with the distinction between the instantaneous rate $r$ in a continuous-time model and the annual equivalent rate $R$ in the corresponding discrete-time model from your savings account. Assuming that the bank pays interest into your account but you do not withdraw any money, what interest rate $r$ do you need so that the money has increased by 5% after one year, i.e., so that the yearly growth factor is $R=1.05$?
:::

## Logistic model

Recall how we introduced the continuous-time logistic model by assuming that the per-capita birth rate declines linearly with the population number and vanishes when the population reaches its carrying capacity. This gave us the equation
$$
\frac{dN}{dt} = rN\left(1 - \frac{N}{K}\right)
$$ {#eq-recall_logistic}
where $r$ is the per-capita growth rate and $K$ is the carrying capacity. 

It turns out that there are several models which all deserve to be called the discrete-time logistic model. The most famous discrete-time logistic model is the Verhulst model:

$$
\begin{split}
N_{t+1} 
&=N_t + R_0 N_t\left(1 - \frac{N_t}{K}\right)\\
&= (R_0+1)N_t\left(1 - \frac{N_t}{K(R_0+1)/R_0}\right)\\
&= RN_t\left(1-\frac{N_t}{\tilde{K}}\right)=f(N_t),
\end{split}
$$ {#eq-verhulst}
We have written the model in two alternative forms, with $R=R_0+1$ and $\tilde{K}=K(R_0+1)/R_0$, because the first form makes it easier to read off the fixed point, while the second form makes the analogy with the continuous-time logistic model more obvious. @eq-verhulst is also often referred to as the logistic map and is a famous example of a chaotic system.

Again it is important to stress that $R_0$ is not a growth _rate_ but a dimensionless growth factor. We are interested in the case where $R_0>0$ and $K>0$.

A fixed point is a value for which $N_{t+1}=N_t$, i.e. a value of $N$ for which the population number does not change from year to year. Thus it is a value $N^*$ for which $f(N^*)=N^*$. Using the second form of the model, we can see easily that the fixed points are $N^*=0$ and $N^*=K$, so $K$ is the carrying capacity.


## Linear stability analysis

We now want to study the stability of the fixed points in discrete-time models. As discussed, fixed points $N^*$ satisfy the equation $N^*=f(N^*)$. We study the stability of the fixed points by looking at the sequence $N_t$ for $t$ close to the fixed point. That means we write $N(t)=N^*+n_t$ for $n_t<<1$. We then have
$$
\begin{split}
N_{t+1} = N^*+n_{t+1}=f(N_t) = f(N^*+n_t) = f(N^*) + f'(N^*)n_t + \ldots
\end{split}
$$ {#eq-taylor_discrete}
where we have used the Taylor expansion of $f$ around $N^*$. Because $N^*$ is a fixed point, we have $f(N^*)=N^*$. Thus we find that
$$
n_{t+1} \approx f'(N^*)n_t
$$ {#eq-linear_discrete}
where we neglected the higher order terms in the Taylor expansion. This is a linear equation for $n_t$ that we know how to solve:
$$
n_t = n_0 (f'(N^*))^t.
$$ {#eq-linear_discrete_solution}
So we have found that:

* If $|f'(N^*)|<1$, then $n_t$ will decrease with time and the fixed point is stable. 

* If $|f'(N^*)|>1$, then $n_t$ will increase with time and the fixed point is unstable. 

If $|f'(N^*)|=1$, then we cannot say anything about the stability of the fixed point from this analysis.

-------------------------------------------------------------------------

:::{#exr-fpl1}
#### + Stability in Verhulst model
Use the stability criterion that we just derived to derive a condition on
the parameter $R_0$ of the Verhulst model that makes the non-zero fixed point
$N^*=K$ a stable fixed point.
:::

-------------------------------------------------------------------------

##  Cobweb diagrams

In the continuous-time case we also had a graphical way to see the stability of fixed points. We will now introduce a graphical method for studying the stability of fixed points in discrete-time models, called the cobweb method.

We plot the function $f(N_t)$ and the line $N_{t+1}=N_t$. The fixed points are the intersection points of the function and the line. We then draw the graph of the sequence $N_t$ by starting at the initial population number $N_0$ and iterating the function $f(N_t)$ to find $N_1$, then iterating the function again to find $N_2$, and so on. The graph of the sequence $N_t$ is called the cobweb. The stability of the fixed points can be read off from the cobweb. If the cobweb spirals into the fixed point, as shown in @fig-cobweb-stable, then the fixed point is stable. If the cobweb spirals out of the fixed point, as shown in @fig-cobweb-unstable, then the fixed point is unstable. You have to press the play button below the figures to see the cobweb diagrams in action.

``` {python}
#| label: fig-cobweb-stable
#| fig-cap: Cobweb diagram for a stable fixed point.
#| fig-alt: Cobweb diagram for a stable fixed point.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

# Define the function
def f(x):
    return x+1.8*x*(1-x)

# Set up the figure and axis
fig, ax = plt.subplots(figsize=(6,6))

# Add axis labels
ax.set_xlabel("$N_t$", loc='right')
ax.set_ylabel("$N_{t+1}$", loc='top')

# Removing numerical labels from the axes
ax.set_xticks([])
ax.set_yticks([])

# Hide the top and right spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))


# Initialize x and y
x, y = 0.8, f(0.8)
# Initialise flag for ignoring first call to animate()
first_call = True

# Animation function
def animate(n):
    global x, y, first_call
    # ignore the first call which is an initialisation call
    if first_call:
        first_call = False
    elif n == 0:
        # Draw initial plots
        x_vals = np.linspace(0, 1.4, 200)
        ax.plot(x_vals, f(x_vals), label='$y=f(N)$')
        ax.plot(x_vals, x_vals, color='black', label='$y=N$')
        # mark the fixed point with a dotted line and a label
        ax.vlines(x=1, ymin=0, ymax=f(1), color='gray', linestyle=':')
        ax.text(1, -0.05, '$N^*$', verticalalignment='top', horizontalalignment='center')
        # add legend
        ax.legend(loc=(0.1, 0.9))
    elif n == 1:
        # On first iteration start on x axis
        # Draw vertical line at x
        ax.plot([x, x], [0, y], color='red')
        # Draw horizontal line at y
        ax.plot([x, y], [y, y], color='red')
    else:
        # Update x and y
        x, new_y = y, f(y)
        # Draw vertical line at x
        ax.plot([x, x], [x, new_y], color='red')
        # Draw horizontal line at y
        ax.plot([x, new_y], [new_y, new_y], color='red')
        y = new_y

# Creating the animation
ani = animation.FuncAnimation(fig, animate, frames=11, repeat=False)

# Display the animation
plt.close()
HTML(ani.to_jshtml())
```

``` {python}
#| label: fig-cobweb-unstable
#| fig-cap: Cobweb diagram for an unstable fixed point.
#| fig-alt: Cobweb diagram for an unstable fixed point.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

# Define the function
def f(x):
    return x+2.2*x*(1-x)

# Set up the figure and axis
fig, ax = plt.subplots(figsize=(6,6))

# Add axis labels
ax.set_xlabel("$N_t$", loc='right')
ax.set_ylabel("$N_{t+1}$", loc='top')

# Removing numerical labels from the axes
ax.set_xticks([])
ax.set_yticks([])

# Hide the top and right spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))


# Initialize x and y
x, y = 0.99, f(0.99)
# Initialise flag for ignoring first call to animate()
first_call = True

# Animation function
def animate(n):
    global x, y, first_call
    # ignore the first call which is an initialisation call
    if first_call:
        first_call = False
    elif n == 0:
        # Draw initial plots
        x_vals = np.linspace(0, 1.4, 200)
        ax.plot(x_vals, f(x_vals), label='$y=f(N)$')
        ax.plot(x_vals, x_vals, color='black', label='$y=N$')
        # mark the fixed point with a dotted line and a label
        ax.vlines(x=1, ymin=0, ymax=f(1), color='gray', linestyle=':')
        ax.text(1, -0.05, '$N^*$', verticalalignment='top', horizontalalignment='center')
        # add legend
        ax.legend(loc=(0.1, 0.9))
    elif n == 1:
        # On first iteration start on x axis
        # Draw vertical line at x
        ax.plot([x, x], [0, y], color='red')
        # Draw horizontal line at y
        ax.plot([x, y], [y, y], color='red')
    else:
        # Update x and y
        x, new_y = y, f(y)
        # Draw vertical line at x
        ax.plot([x, x], [x, new_y], color='red')
        # Draw horizontal line at y
        ax.plot([x, new_y], [new_y, new_y], color='red')
        y = new_y

# Creating the animation
ani = animation.FuncAnimation(fig, animate, frames=28, repeat=False)

# Display the animation
plt.close()
HTML(ani.to_jshtml())
```

The oscillatory nature of the sequence $N_t$, hopping from one side of the fixed point to the other, that creates the cobweb pattern is due to the fact that the slope of $f$ is negative at the fixed point. 
Ecologically, what is happening as the growth factor increases through $R=3$ is that in 
a single year the population grows so much that it exceeds its carrying capacity. That then
leads to unfavourable conditions in the following year, leading to a decrease below carrying capacity.
Such oscillations in population numbers are not possible in a continuous-time model for a single un-structured population.

In @fig-cobweb-stable the oscillations get damped over time and the system evolves towards a steady state. In @fig-cobweb-stable the system evolves towards a state where the population number oscillates between two values. This is called a period-two orbit. We will have more to say about this in @sec-period-doubling.

The graphical method for visualising the iterations will work also when the slope is positive at the fixed point, but it will not look like a cobweb because the system will not be oscillating around the fixed
point but will be evolving towards it. @fig-cobweb-positive-slope shows the cobweb for a stable fixed point with positive slope $0<f'(N^*)<1$ and @fig-cobweb-positive-slope-unstable shows the cobweb for an unstable fixed point with positive slope $f'(N^*)>1$.

```{python}
#| label: fig-cobweb-positive-slope
#| fig-cap: Cobweb diagram for a stable fixed point with positive slope.
#| fig-alt: Cobweb diagram for a stable fixed point with positive slope.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
# Define the function
def f(x):
    return x+0.8*x*(1-x)

# Set up the figure and axis
fig, ax = plt.subplots(figsize=(6,6))

# Add axis labels
ax.set_xlabel("$N_t$", loc='right')
ax.set_ylabel("$N_{t+1}$", loc='top')

# Removing numerical labels from the axes
ax.set_xticks([])
ax.set_yticks([])

# Hide the top and right spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))


# Initialize x and y
x, y = 0.5, f(0.5)
# Initialise flag for ignoring first call to animate()
first_call = True

# Animation function
def animate(n):
    global x, y, first_call
    # ignore the first call which is an initialisation call
    if first_call:
        first_call = False
    elif n == 0:
        # Draw initial plots
        x_vals = np.linspace(0, 1.4, 200)
        ax.plot(x_vals, f(x_vals), label='$y=f(N)$')
        ax.plot(x_vals, x_vals, color='black', label='$y=N$')
        # mark the fixed point with a dotted line and a label
        ax.vlines(x=1, ymin=0, ymax=f(1), color='gray', linestyle=':')
        ax.text(1, -0.05, '$N^*$', verticalalignment='top', horizontalalignment='center')
        # add legend
        ax.legend(loc=(0.1, 0.9))
    elif n == 1:
        # On first iteration start on x axis
        # Draw vertical line at x
        ax.plot([x, x], [0, y], color='red')
        # Draw horizontal line at y
        ax.plot([x, y], [y, y], color='red')
    else:
        # Update x and y
        x, new_y = y, f(y)
        # Draw vertical line at x
        ax.plot([x, x], [x, new_y], color='red')
        # Draw horizontal line at y
        ax.plot([x, new_y], [new_y, new_y], color='red')
        y = new_y

# Creating the animation
ani = animation.FuncAnimation(fig, animate, frames=7, repeat=False)

# Display the animation
plt.close()
HTML(ani.to_jshtml())
```



```{python}
#| label: fig-cobweb-positive-slope-unstable
#| fig-cap: Cobweb diagram for an unstable fixed point with positive slope.
#| fig-alt: Cobweb diagram for an unstable fixed point with positive slope.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

# Define the quadratic function with fixed points at 0 and 1.
def f(x):
    return 0.5*x + 0.5*x**2

# Set up the figure and axis
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlabel("$x_t$", loc='right')
ax.set_ylabel("$x_{t+1}$", loc='top')

# Remove numerical labels from the axes
ax.set_xticks([])
ax.set_yticks([])

# Hide the top and right spines; reposition bottom and left spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Set axis limits to cover the fixed points and the orbit
ax.set_xlim(0, 1.1)
ax.set_ylim(0, 1.1)

# Initialize the orbit; starting near the unstable fixed point at 1
x, y = 0.9, f(0.9)
first_call = True  # flag to ignore the very first call

def animate(n):
    global x, y, first_call
    # The first call (used for initialization) is skipped.
    if first_call:
        first_call = False
    elif n == 0:
        # Plot the function and the identity line.
        x_vals = np.linspace(0, 1.1, 300)
        ax.plot(x_vals, f(x_vals), label='$y=f(x)$')
        ax.plot(x_vals, x_vals, color='black', label='$y=x$')
        # Mark the fixed points: stable at 0 and unstable at 1.
        ax.vlines(x=1, ymin=0, ymax=f(1), color='gray', linestyle=':')
        ax.text(1, -0.05, '$x^*=1$', verticalalignment='top', horizontalalignment='center')
        ax.vlines(x=0, ymin=0, ymax=f(0), color='gray', linestyle=':')
        ax.text(0, -0.05, '$x^*=0$', verticalalignment='top', horizontalalignment='center')
        ax.legend(loc=(0.1, 0.9))
    elif n == 1:
        # First iteration: draw vertical then horizontal segments.
        ax.plot([x, x], [x, y], color='red')
        ax.plot([x, y], [y, y], color='red')
    else:
        # Draw vertical segment from (x, x) to (x, f(x))
        ax.plot([x, x], [x, y], color='red')
        # Draw horizontal segment from (x, f(x)) to (f(x), f(x))
        ax.plot([x, y], [y, y], color='red')
        # Update the orbit
        x, y = y, f(y)

# Create the animation with 14 frames (non-repeating)
ani = animation.FuncAnimation(fig, animate, frames=14, repeat=False)

# Display the animation (for Jupyter Notebook use)
plt.close()  # Prevent duplicate static output in some environments
HTML(ani.to_jshtml())
```

----------------------------------------------------------------------

::: {#exr-discrete_logistic}
#### + Verhulst model
For some choices of the parameters, the Verhulst model
$$
N_{t+1}=RN_t\left(1-\frac{N_t}{\tilde{K}}\right)
$$ {#eq-ex_Verhulst}
can
lead to negative population numbers even when initially starting with a positive population below
its carrying capacity. Derive the condition on the parameters for this to happen. One good
way to approach this is to think about what the cobweb diagram would have to look like for
such a scenario.
:::

----------------------------------------------------------------------



## Other models with limited carrying capacity

You showed in @exr-discrete_logistic that the Verhulst model has the disadvantage that it can give negative population numbers. There are several other models that are discrete-time versions of the logistic model and do not have this problem. We will now look at the two most important of them.

### Ricker model

Many fish species, like salmon, have distinct breeding seasons and their reproduction shows strong density dependence - when population density is too high, fewer offspring survive due to competition for spawning sites. The Ricker model captures this behavior through the equation:

$$
N_{t+1} = N_t\, e^{R_0\left(1 - \frac{N_t}{K}\right)}.
$$ {#eq-ricker}

By moving the logistic factor inside the exponential, the Ricker model prevents negative population numbers. The fixed points are still $N^*=0$ and $N^*=K$. Ricker introduced this model to describe salmon populations.

----------------------------------------------------------------------

::: {#exr-ricker}
#### * Ricker model
Find the fixed points in the Ricker model
$$
N_{t+1} = N_t\, e^{R_0\left(1 - \frac{N_t}{K}\right)}.
$$ {#eq-ex_ricker}
and investigate their stability. Do this both analytically and by drawing cobweb diagrams.
Allow also negative values of $R_0$ in your analysis, even though this is not ecologically realistic.
Note that you will then need at least three cobweb diagrams because there are then two bifurcations.
:::

----------------------------------------------------------------------


### Beverton-Holt model

The Beverton-Holt model, introduced by Ray Beverton and Sidney Holt in 1957, was developed to understand fish population dynamics. The model arose from their groundbreaking work on sustainable fisheries management while working at the Fisheries Laboratory in Lowestoft, UK. They were particularly interested in how the number of young fish (recruits) entering a population depends on the number of parent fish (spawning stock).

They proposed the model

$$
N_{t+1} = \frac{R N_t}{1 + \frac{R-1}{K}N_t}.
$$ {#eq-beverton_holt}

This has been a very influential model in fisheries science. On the face of it the model does not look very similar to the logistic model, but we will see the relationship when we solve the model. The trick is to make a change of variables from $N_t$ to $u_t = 1/N_t$. Then we have
$$
u_{t+1} = \frac{1}{N_{t+1}} = \frac{1 + \frac{R-1}{K}N_t}{R N_t} = \frac{u_t}{R} + \frac{R-1}{R K}.
$$ {#eq-beverton_holt_u}
This is a linear equation for $u_t$, and linear equations are easy to solve. The easiest way to proceed is to look at the first few terms of the sequence $u_t$ and guess the general form of the solution. We find
$$\begin{split}
u_1 &= \frac{u_0}{R} + \frac{R-1}{R K},\\
u_2 &= \frac{u_0}{R^2} + \frac{R-1}{R K}\left(1 + \frac{1}{R}\right),\\
u_3 &= \frac{u_0}{R^3} + \frac{R-1}{R K}\left(1 + \frac{1}{R} + \frac{1}{R^2}\right),\\
&\vdots\\
u_t &= \frac{u_0}{R^t} + \frac{R-1}{R K}\left(1 + \frac{1}{R} + \frac{1}{R^2} + \ldots + \frac{1}{R^{t-1}}\right).
\end{split}
$$ {#eq-beverton_holt_u_solution}
The sum in the second term is a geometric series. We know the general formula for a geometric series:
$$
1 + x + x^2 + \ldots + x^{t-1} = \frac{1 - x^t}{1 - x}.
$$ {#eq-geometric_series}

We can use this with $x=1/R$ to sum terms in the second term. We find
$$
u_t = \frac{u_0}{R^t} + \frac{R-1}{R K}\frac{1 - (1/R)^t}{1 - 1/R}.
$$
We simplify this a bit and bring everything on the same denominator.
$$
u_t = \frac{u_0}{R^t} - \frac{(1/R)^t-1}{K}
=\frac{Ku_0-1+R^t}{KR^t}.
$$ {#eq-beverton_holt_u_solution_simplified}


We can now change back to $N_t=1/u_t$ to find the solution to the Beverton-Holt model. We find
$$
\begin{split}
N_t &= \frac{1}{u_t}=\frac{K R^t}{Ku_0-1+R^t}\\
&=\frac{K/u_0}{KR^{-t}-R^{-t}/u_0+1/u_0}\\
&=\frac{KN_0}{N_0+(K-N_0)R^{-t}}.
\end{split}
$$ {#eq-beverton_holt_solution}

This is the solution to the Beverton-Holt model. Comparing this to the solution of the continuous-time logistic model
from @eq-logistic-solution,
$$
N(t) = \frac{KN_0}{N_0+(K-N_0)\exp(-rt)},
$$ {#eq-recall_logistic_solution}
we see that they agree at integer times $t$ if we measure time in years and set
$R=\exp(r \cdot 1\text{ year}).$

----------------------------------------------------------------------

::: {#exr-beverton_holt}
#### Beverton-Holt model
Find the fixed points in the Beverton-Holt model
$$
N_{t+1} = \frac{R N_t}{1 + \frac{R-1}{K}N_t}.
$$ {#eq-ex_beverton_holt}
and investigate their stability. Do this both analytically and by drawing cobweb diagrams.
:::

----------------------------------------------------------------------


## Discrete-time harvesting model

We will now look at an example of a discrete-time model with harvesting and apply the techniques we have learned. The model has the standard discrete-time model form $N_{t+1}=f(N_t)$, where $f$ in our example is
$$
f(N) = \frac{b N^2}{1+N^2}-EN.
$$
The constant $b>2$ determines the growth rate of the population and the harvesting rate is determined by the harvesting effort $E$. 

We start by studying the model without harvesting, so we set $E=0$ for now. As usual, we start by looking at the steady states of the model. The fixed points are the solutions to the equation 
$$
N^* = \frac{b\,{N^*}^2}{1+{N^*}^2}.
$$ 
There is the obvious solution $N^*=0$. We can then find the non-zero solutions by dividing both sides by $N^*$ and multiply them by $1+{N^*}^2$ to get the equation
$$
1+{N^*}^2 = bN^*.
$$
This is a quadratic equation for $N^*$, which we could rewrite in the more conventional form
$$
{N^*}^2 - bN^* + 1 = 0.
$$
The solutions to this equation are
$$
N^*_\pm = \frac{b\pm\sqrt{b^2-4}}{2}.
$$
The solutions are real if $b^2-4\geq 0$, i.e. if $b\geq 2$, which we have stipulated earlier. Both solutions are positive. 

We now have enough information to draw a good sketch to understand the dynamics of the model. We can draw the function $f(N)$ and the line $N_{t+1}=N_t$. It may not be immediately obvious what the sketch of $f(N)=bN^2/(1+N^2)$ looks like. We'll reason ourselves through this in steps:

- First let us consider what happens near $N=0$. There the function is approximately $f(N)\approx bN^2$. This is a parabola that opens upwards. The function is zero at $N=0$ and increases quadratically with $N$. 

- Next we consider what happens as $N$ becomes large. There the function is approximately $f(N)\approx b$. So the graph has a horizontal asymptote at $y=b$.

- We know that in between there are two fixed points. That means the graph needs to cross the diagonal line $y=N$ twice.

- Finally we observe that the function is monotonically increasing. 

If we now draw something that has all these features, we will have a sufficiently good sketch of the function for our purpose of understanding the dynamics of the model. We will necessarily end up with something that qualitatively looks like the graph in @fig-discrete-harvesting-function.

```{python}
#| label: fig-discrete-harvesting-function
#| fig-cap: Graph of the function $f(N)=\frac{bN^2}{1+N^2}$.
#| fig-alt: Graph of the function $f(N)=\frac{bN^2}{1+N^2}$.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle

# Define the function
def f(N, b):
    return b*N**2/(1+N**2)

# Parameter value
b = 2.4

# Fixed points
Np = (b+np.sqrt(b**2-4))/2
Nm = (b-np.sqrt(b**2-4))/2

# Adding axis labels
plt.figure(figsize=(6,6))
plt.xlabel('$N_t$', loc='right')
plt.ylabel('$N_{t+1}$', loc='top')

# Removing numerical labels from the axes
plt.xticks([])  # Removing labels on the horizontal axis
plt.yticks([])  # Removing labels on the vertical axis

# Hide the top and right spines
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Plot the function
N_vals = np.linspace(0, b*1.2, 200)
plt.plot(N_vals, f(N_vals, b), label='$y=f(N)$')

# Add diagonal
plt.plot(N_vals, N_vals, 'k-', label='$y=N$')

# Add red dot at stable fixed points
circle = Circle((Np,Np), 0.05, color='red', fill=True)
ax.add_patch(circle)
circle = Circle((0,0), 0.05, color='red', fill=True)
ax.add_patch(circle)
# Add red circle at unstable fixed point
circle = Circle((Nm,Nm), 0.05, color='red', fill=False)
ax.add_patch(circle)

# Mark fixed points on x axis
plt.vlines(Np, 0, Np, color='gray', linestyle=':')
plt.text(Np, -0.3, '$N^*_+$', ha='center')
plt.vlines(Nm, 0, Nm, color='gray', linestyle=':')
plt.text(Nm, -0.3, '$N^*_-$', ha='center')

# Add horizontal asymptote
plt.hlines(b, 0, b*1.2, color='gray', linestyle='--', label='$y=b$')

ax.legend(loc='center right')
plt.show()
```

Using our cobweb technique, or simply looking at the slope of $f$ at the fixed points, we can easily convince ourselves that the extinction fixed point is stable, the smaller non-zero fixed point $N^*_-$ is unstable and the larger fixed point $N^*_+$ is stable. in @fig-discrete-harvesting-function we have indicated the stable fixed points by solid circles and the unstable fixed points by open circles. So when the population number is larger than $N^*_-$ it will grow towards $N^*_+$, and when it is smaller than $N^*_-$ it will go extinct. So this model exhibits a strong Allee effect with critical depensation. $N^*_-$ is the smallest viable population size.

We can now add harvesting to the model. The extra term in the function $f(N)$ is $-EN$. This lowers the graph of $f(N)$ by an amount that grows linearly with $N$. This is illustrated in @fig-discrete-harvesting-function-harvesting. 

```{python}
#| label: fig-discrete-harvesting-function-harvesting
#| fig-cap: Graph of the function $f(N)=\frac{bN^2}{1+N^2}-EN$.
#| fig-alt: Graph of the function $f(N)=\frac{bN^2}{1+N^2}-EN$.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
# Define the function
def f(N, b, E):
    return b*N**2/(1+N**2)-E*N

# Parameter value
b = 2.4
E1 = 0.1
E2 = 0.2
E3 = 0.3

# Adding axis labels
plt.figure(figsize=(6,6))
plt.xlabel('$N_t$', loc='right')
plt.ylabel('$N_{t+1}$', loc='top')

# Removing numerical labels from the axes
plt.xticks([])  # Removing labels on the horizontal axis
plt.yticks([])  # Removing labels on the vertical axis

# Hide the top and right spines
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Plot the function
N_vals = np.linspace(0, b*1.2, 200)
plt.plot(N_vals, f(N_vals, b, 0), label='$E=0$')
plt.plot(N_vals, f(N_vals, b, E1), label='$0<E<E_c$')
plt.plot(N_vals, f(N_vals, b, E2), label='$E=E_c$')
plt.plot(N_vals, f(N_vals, b, E3), label='$E>E_c$')

# Add diagonal
plt.plot(N_vals, N_vals, 'k-',)

ax.legend(loc=(0.1,0.6))
plt.show()
```
We see that as the harvesting effort $E$ increases, the two fixed points move closer together. At a critical value $E_c$ the two fixed points merge and disappear. The population number will then go extinct for all initial population numbers. 

Let us find the critical value $E_c$. For that we first determine the location of the fixed points in the presence of harvesting. So we solve the equation
$$
N^* = \frac{b\,{N^*}^2}{1+{N^*}^2}-EN^*.
$$
Again this has a solution $N^*=0$. We can then find the non-zero solutions by dividing both sides by $N^*$ and multiply them by $1+{N^*}^2$ to get the equation
$$
(1+E){N^*}^2-bN^*+1+E = 0.
$$
This is solved by
$$
N^*_\pm = \frac{\frac{b}{1+E}\pm\sqrt{\left(\frac{b}{1+E}\right)^2-4}}{2}.
$$

We see that these solutions are real only if $\left(\frac{b}{1+E}\right)^2-4\geq 0$, i.e., if $E< \frac{b-2}{2}$. Thus the critical effort is $E_c=\frac{b-2}{2}$. Fishing above this level will lead to extinction of the population. But even fishing just near this level is risky because the population number will be very close to the minimum viable population and a small disturbance could lead to extinction.


```{python}
#| label: fig-discrete-harvesting-function-bifurcation
#| fig-cap: Bifurcation diagram for the discrete-time harvesting model.
#| fig-alt: Diagram showing the fixed point of the discrete-time harvesting model as a function of the harvesting effort.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

def fixed_point_stable(E):
    C = 2.4 / (1 + E)
    return (C + np.sqrt(C**2 - 4))/2

def fixed_point_unstable(E):
    C = 2.4 / (1 + E)
    return (C - np.sqrt(C**2 - 4))/2

# Generate a range of harvesting efforts E between 0 and 0.3.
E_vals = np.linspace(0, 0.2, 200)
N_stable = fixed_point_stable(E_vals)  # Analytical fixed points for each E.
N_unstable = fixed_point_unstable(E_vals)
E_extinction = np.linspace(0, 0.3, 300)
N_extinction = 0 * E_extinction

# Set up the bifurcation diagram plot.
plt.figure(figsize=(6,3))
plt.xlabel('$E$', loc='right')
plt.ylabel('$N^*$', loc='top')

# Hide the top and right spines, and reposition the bottom and left spines.
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Plot the analytical fixed point branch.
plt.plot(E_vals, N_stable, 'b-', label='Coexistence fixed point')
plt.plot(E_vals, N_unstable, 'r--', label='Extinction threshold')
plt.plot(E_extinction, N_extinction, 'b-', label='Extinction fixed point')
plt.legend(loc=(0.5,0.75))
plt.show()
```

## Period-doubling route to chaos {#sec-period-doubling}

Take another look at @fig-cobweb-stable and @fig-cobweb-unstable. Just a little change in
the function $f(N)$ changed the nature of the fixed point. Such a change can be the consequence
of a small change in a model parameter, for example the intrinsic growth rate. 

We will use the logistic map to illustrate the period-doubling route to chaos, although
the phenomenon is more general. The logistic map is a simple discrete-time model for population growth that exhibits a period-doubling route to chaos. It is defined as
$$
X_{t+1} = R\,X_t\,(1-X_t) =: f(X_t).
$$
It is the same as the Verhulst model @eq-verhulst, just written in terms of $X_t = N_t/\tilde{K}$.
@fig-period-doubling-bifurcation shows the graph of $f(X)$ of the Verhulst model at
three different values of the intrinsic growth factor $R$. For $R=2.8$ the slope of 
$f$ at the fixed point is less steep than $-1$ and thus the fixed point is stable, as in
@fig-cobweb-stable. For $R=3.2$ the slope of $f$ at the fixed point is steeper than $-1$
and thus the fixed point is unstable and the population number starts to oscillate, as in @fig-cobweb-unstable. At $R=3$ the system switches from one behaviour to the other. That
is the bifurcation point.

```{python}
#| label: fig-period-doubling-bifurcation
#| fig-cap: Plot showing a period-doubling bifurcation in the Verhulst model.
#| fig-alt: Graph illustrating a period-doubling bifurcation where a stable fixed point loses stability and a stable period-2 orbit emerges.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

def logistic_map(x, r):
    # Logistic map: f(x) = r*x*(1-x)
    return r * x * (1-x)

# Set up the figure and axis for the period-doubling bifurcation plot
plt.figure(figsize=(6,6))
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Define the range for x from 0 to 1
x_vals = np.linspace(0, 1, 400)

# Plot the logistic map for different values of r to illustrate the bifurcation
for r in [2.8, 3.0, 3.2]:
    label = "$R=" + str(r) + "$"
    plt.plot(x_vals, logistic_map(x_vals, r), label=label)

# Plot the diagonal line y=x
plt.plot(x_vals, x_vals, 'k-')
ax.legend(loc=(0.1, 0.6))
plt.xlabel("$X_t$")
plt.ylabel(r"$X_{t+1}$")
plt.show()
```

@fig-period-doubling-new shows a simplified bifurcation diagram for the Verhulst model. A bifurcation diagram shows the location of fixed points or periodic orbits, with stable fixed points or stable periodic orbits represented by solid lines and unstable fixed points or unstable periodic orbits represented by dashed lines. Reading the diagram from left to right, which corresponds to increasing growth factor $R$ in the Verhulst model, we see how at first the stable fixed point (which is located at the carrying capacity $K$) moves towards larger population sizes. At $R=3$ it becomes unstable and spawns a stable periodic orbit whose
amplitude grows until that periodic orbit itself becomes unstable, in another period-doubling bifurcation.

```{python}
#| label: fig-period-doubling-new
#| fig-cap: Bifurcation diagram for the period-doubling bifurcation.
#| fig-alt: Diagram showing analytic fixed points and the period-2 orbit of the logistic map as a function of r.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

# Fixed point of the logistic map: x* = 1 - 1/r (for r > 1).
r_vals_fp = np.linspace(1, 4, 300)
x_fp = 1 - 1 / r_vals_fp

# The fixed point is stable for 1 < r < 3 and becomes unstable for r ≥ 3.
stable_mask = r_vals_fp < 3
unstable_mask = r_vals_fp >= 3

r_stable_fp = r_vals_fp[stable_mask]
x_stable_fp = x_fp[stable_mask]
r_unstable_fp = r_vals_fp[unstable_mask]
x_unstable_fp = x_fp[unstable_mask]

# For r ≥ 3, the period-2 orbit is given by:
# x_{1,2} = (r+1 ± sqrt((r+1)(r-3)))/(2r)
r_vals_pd = np.linspace(3, 4, 300)
x_pd_plus = (r_vals_pd + 1 + np.sqrt((r_vals_pd+1)*(r_vals_pd-3))) / (2*r_vals_pd)
x_pd_minus = (r_vals_pd + 1 - np.sqrt((r_vals_pd+1)*(r_vals_pd-3))) / (2*r_vals_pd)

# Define a stability threshold for the period-2 orbit (approximately, r_pd_crit ≈ 1+√6 ~ 3.449).
r_pd_crit = 1 + np.sqrt(6)
mask_stable_pd = r_vals_pd <= r_pd_crit
mask_unstable_pd = r_vals_pd > r_pd_crit
r_pd_stable = r_vals_pd[mask_stable_pd]
x_pd_plus_stable = x_pd_plus[mask_stable_pd]
x_pd_minus_stable = x_pd_minus[mask_stable_pd]
r_pd_unstable = r_vals_pd[mask_unstable_pd]
x_pd_plus_unstable = x_pd_plus[mask_unstable_pd]
x_pd_minus_unstable = x_pd_minus[mask_unstable_pd]

plt.figure(figsize=(8,6))
# Plot fixed point branch.
plt.plot(r_stable_fp, x_stable_fp, 'b-', linewidth=2, label='Stable fixed point')
plt.plot(r_unstable_fp, x_unstable_fp, 'r--', linewidth=2, label='Unstable fixed point')
# Plot period-2 branches.
plt.plot(r_pd_stable, x_pd_plus_stable, 'b-', linewidth=2, label='Stable period-2')
plt.plot(r_pd_stable, x_pd_minus_stable, 'b-', linewidth=2)
plt.plot(r_pd_unstable, x_pd_plus_unstable, 'r--', linewidth=2, label='Unstable period-2')
plt.plot(r_pd_unstable, x_pd_minus_unstable, 'r--', linewidth=2)
plt.xlabel("$R$")
plt.ylabel("$N^*$")
plt.title("Bifurcation Diagram: Period–Doubling (Logistic Map)")
plt.legend(loc='best')
plt.show()
```


@fig-period-doubling-new does not show the period 4 orbit that emerges when the period 2 orbit becomes unstable. The full diagram quickly becomes very messy as $R$ increases, as shown in @fig-period-doubling-new-full. Period-doubling cascades continue until the system enters a chaotic regime for $R>3.56995$.


```{python}
#| label: fig-period-doubling-new-full
#| fig-cap: Bifurcation diagram for the period-doubling bifurcation.
#| fig-alt: Diagram showing analytic fixed points and the period-2 orbit of the logistic map as a function of r.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
# Compute and plot the bifurcation diagram for the logistic map,
# illustrating the period-doubling route to chaos.

# Define a dense array of r values over the interval of interest.
r_values = np.linspace(3.4, 4.0, 10000)
# Start with an initial condition for each r value.
x = 0.5 * np.ones_like(r_values)

# Iterate the logistic map to let transients die out.
transient_iterations = 1000
for i in range(transient_iterations):
    x = r_values * x * (1 - x)

# Iterate further and plot the remaining iterations (the attractor points).
attractor_iterations = 200
for i in range(attractor_iterations):
    x = r_values * x * (1 - x)
    plt.plot(r_values, x, ',k', alpha=0.25)

plt.xlabel("r")
plt.ylabel("x")
plt.title("Bifurcation Diagram: Period-Doubling Route to Chaos in the Logistic Map")
plt.show()
```

In the chaotic regime the system displays highly sensitive dependence on initial conditions, where small differences in the starting population can result in vastly different outcomes over time. The period-doubling route to chaos, as seen in the logistic map, is a classic example of how simple nonlinear equations can produce complex and unpredictable behavior. How important chaos is for ecological systems is a subject of ongoing debate.


## Transcritical and pitchfork bifurcations

As mentioned before, a bifurcation is a change in the existence and stability of fixed points or periodic orbits as the parameters of the model are varied.
You have met bifurcations in continuous-time models already in your Classical Dynamics module. You have seen there that in one-dimensional systems described by a single ODE there are three different types of bifurcation: saddle-node, pitchfork, transcritical. The same types of bifurcations can occur in discrete-time models and we will discuss and visualise each of these bifurcation types below. These bifurcations happen if there is a fixed point with $f'(N^*)=1$. Then there is also one more type: the period-doubling bifurcation, which happens when $f'(N^*)=-1$, and which we have met in @sec-period-doubling.

### Saddle-node bifurcation

We have already seen a saddle-node bifurcation in the discrete-time harvesting mode, where two fixed points merge and disappear as the parameter is varied. This is also sometimes referred to as a tangent bifurcation.
@fig-saddle-node-bifurcation shows an example of a function $f(N)$ that depends on a parameter $r$ in such a way that for $r>0$ the graph of $f(N)$ crosses the diagonal twice, which means that there are two fixed points. Then at exactly $r=0$ the function is tangent to the diagonal, i.e, there is only a single fixed point. Then for $r<0$ the function does not touch the diagonal so that there are no fixed points left. 


```{python}
#| label: fig-saddle-node-bifurcation
#| fig-cap: Plot showing a saddle-node bifurcation.
#| fig-alt: Graph illustrating a saddle-node bifurcation
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
# Create a function for plotting
def f(N, r):
    return 2*N*(1-N) - 0.125 + r

# Set up the plot
plt.figure(figsize=(8, 6))

plt.figure(figsize=(6,3))
plt.xlabel('$N_t$', loc='right')
plt.ylabel('$N_{t+1}$', loc='top')

# Hide the top and right spines
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
# Move the bottom spine to y=0 and the left spine to x=0
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Plot the function for different values of r
N_vals = np.linspace(0, 0.5, 200)
plt.plot(N_vals, f(N_vals, -0.075), label='$r<0$')
plt.plot(N_vals, f(N_vals, 0), label='$r=0$')
plt.plot(N_vals, f(N_vals, 0.075), label='$r>0$')

# Add diagonal line
plt.plot(N_vals, N_vals, 'k-')

ax.legend(loc=(0.1,0.6))
plt.show()
```

@fig-saddle-node-new shows the corresponding bifurcation diagram.
```{python}
#| label: fig-saddle-node-new
#| fig-cap: Bifurcation diagram for a saddle-node bifurcation.
#| fig-alt: Diagram showing analytic fixed points for a saddle-node bifurcation.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

# Analytic fixed points: N = (1 ± sqrt(8*r))/4 (for r >= 0).
r_vals = np.linspace(0, 0.075, 300)
N_plus = (1 + np.sqrt(8 * r_vals)) / 4    # Candidate branch (stable for 0 < r < 0.5)
N_minus = (1 - np.sqrt(8 * r_vals)) / 4   # Always unstable

plt.figure(figsize=(8,6))
plt.plot(r_vals, N_plus, 'b-', linewidth=2, label='Stable branch')
plt.plot(r_vals, N_minus, 'r--', linewidth=2, label='Unstable branch')
plt.xlabel("$r$")
plt.ylabel("$N^*$")
plt.title("Bifurcation Diagram: Saddle–Node Bifurcation")
plt.legend(loc='best')
# Set x-axis range
plt.xlim(-0.075, 0.075)
plt.show()
```

### Transcritical bifurcation

```{python}
#| label: fig-transcritical-bifurcation
#| fig-cap: Plot showing a transcritical bifurcation.
#| fig-alt: Graph illustrating a transcritical bifurcation with fixed points exchanging stability.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
def f_trans(N, r):
  # Transcritical bifurcation normal form:
  # f(N) = (1+r)N - N^2, with fixed points at N=0 and N=r.
  return 1 + (1+r)*(N-1) - (N-1)**2

# Set up the figure and axis for the transcritical bifurcation
plt.figure(figsize=(8, 6))
plt.yticks([])
plt.xticks([])
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))
# Define the range for N
N_vals = np.linspace(0, 0.5, 200)
# Plot f(N) for different values of r to illustrate the bifurcation
for rv in [-0.5, 0, 0.5]:
  if rv < 0:
    label = '$r<0$'
  elif rv == 0:
    label = '$r=0$'
  else:
    label = '$r>0$'
  plt.plot(N_vals, f_trans(N_vals, rv), label=label)
# Plot the diagonal line where y = N
plt.plot(N_vals, N_vals, 'k-')
ax.legend(loc=(0.1, 0.6))
plt.show()
```

```{python}
#| label: diag-transcritical-new
#| fig-cap: Bifurcation diagram for a transcritical bifurcation.
#| fig-alt: Diagram showing analytic fixed points for a transcritical bifurcation.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

# Analytic fixed points: N = 0.25  and  N = 0.25 + r.
r_vals = np.linspace(-2, 2, 300)
N1 = 0.25 * np.ones_like(r_vals)
N2 = 0.25 + r_vals

plt.figure(figsize=(8,6))
# Split parameter range for different stability behaviors:
r_neg = r_vals[r_vals < 0]
r_pos = r_vals[r_vals >= 0]
N1_neg = 0.25 * np.ones_like(r_neg)
N1_pos = 0.25 * np.ones_like(r_pos)
N2_neg = 0.25 + r_neg
N2_pos = 0.25 + r_pos

plt.plot(r_neg, N1_neg, 'b-', linewidth=2, label='Stable: $N=0.25$')
plt.plot(r_neg, N2_neg, 'r--', linewidth=2, label='Unstable: $N=0.25+r$')
plt.plot(r_pos, N1_pos, 'r--', linewidth=2)
plt.plot(r_pos, N2_pos, 'b-', linewidth=2, label='Stable: $N=0.25+r$')
plt.xlabel("$r$")
plt.ylabel("$N^*$")
plt.title("Bifurcation Diagram: Transcritical Bifurcation")
plt.legend(loc='best')
plt.show()
```

### Pitchfork bifurcation

```{python}
#| label: fig-pitchfork-bifurcation
#| fig-cap: Plot showing a pitchfork bifurcation.
#| fig-alt: Graph illustrating a pitchfork bifurcation with symmetric fixed points.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
def f_pitchfork(N, r):
    # Pitchfork bifurcation normal form with bifurcation at N = 0.25:
    # f(N) = 0.25 + (1+r)*(N-0.25) - (N-0.25)**3,
    # which has a fixed point at N = 0.25 for all r, and for r > 0,
    # two symmetric fixed points at N = 0.25 ± √r.
    return 1 + (1+r)*(N-1) - (N-1)**3

# Set up the figure and axis for the pitchfork bifurcation
plt.figure(figsize=(8,6))
plt.yticks([])
plt.xticks([])
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))

# Define the range for N to capture symmetric dynamics
N_vals = np.linspace(0, 2, 300)

# Plot f(N) for different values of r to illustrate the bifurcation
for rv in [-0.4, 0, 0.4]:
    if rv < 0:
        label = '$r<0$'
    elif rv == 0:
        label = '$r=0$'
    else:
        label = '$r>0$'
    plt.plot(N_vals, f_pitchfork(N_vals, rv), label=label)

# Plot the diagonal line where y = N
plt.plot(N_vals, N_vals, 'k-')
ax.legend(loc=(0.1, 0.6))
plt.show()
```

```{python}
#| label: diag-pitchfork-new
#| fig-cap: Bifurcation diagram for a pitchfork bifurcation.
#| fig-alt: Diagram showing analytic fixed points for a pitchfork bifurcation.
#| echo: false
import numpy as np
import matplotlib.pyplot as plt

# Analytic fixed points (after translating x = N-1):
# Trivial branch: N = 1 for all r.
# Nontrivial branches: N = 1 ± √r for r ≥ 0.
r_all = np.linspace(-2, 1, 300)
N_triv = np.ones_like(r_all)
r_pos = np.linspace(0, 1, 300)
N_plus = 1 + np.sqrt(r_pos)
N_minus = 1 - np.sqrt(r_pos)

plt.figure(figsize=(8,6))
# For r < 0, only the trivial branch exists and is assumed stable.
plt.plot(r_all[r_all < 0], N_triv[r_all < 0], 'b-', linewidth=2, label='Stable: $N=1$')
# For r ≥ 0, the trivial branch becomes unstable.
plt.plot(r_pos, np.ones_like(r_pos), 'r--', linewidth=2, label='Unstable: $N=1$')
# The nontrivial branches (stable when they appear).
plt.plot(r_pos, N_plus, 'b-', linewidth=2, label='Stable: $N=1+\\sqrt{r}$')
plt.plot(r_pos, N_minus, 'b-', linewidth=2, label='Stable: $N=1-\\sqrt{r}$')
plt.xlabel("$r$")
plt.ylabel("$N^*$")
plt.title("Bifurcation Diagram: Pitchfork Bifurcation")
plt.legend(loc='best')
plt.show()
```



-----------------------------------------

::: {#exr-finches}
#### o House finches

_[Note: in this problem we combine a continuous time model for the dynamics within a single year with
a discrete model for the dynamics from one year to the next.
 The subscript $t \in \mathbb{Z}$ refers to the discrete year whereas
$\tau\in\mathbb{R}$ will indicate the continuous time within a single year.]_

A population of house finches resides in an isolated region in North America. 
In this problem you want to find out about the long-term prospects for the population.

Each year the
males and females begin their search for mates at the beginning of winter with a
combined population number $N_t$ in year $t$, and form $P_t$ breeding pairs by the end
of this search period, the start of the breeding season.

The mate search period lasts from within-year time $\tau = 0$ to the end of the search
period at within-year time $\tau = T$. Assume that there is a 1:1 sex ratio and that
males $M(\tau)$ and females $F(\tau)$ locate one another randomly to make a pair 
at rate $\sigma$, such that the number  $M(\tau)$ of males  that are not in a pair at time $\tau$ satisfies
$$\frac{dM}{d\tau}=-\sigma \,M\,F $$
and similarly  the number  $F$ of females  that are not in a pair at time $\tau$  satisfies
$$\frac{dF}{d\tau}=-\sigma \,M\,F. $$

You are given that the number of breeding pairs that establish a nest and breed
successfully is $G(P_t)P_t$, where the fraction $G(P_t)$ takes the particular form
$$G(P_t) = \frac{1}{1+P_t/\delta},$$
where $\delta$ represents the density of available nesting sites.
Each pair that reproduces successfully has a mean number $c$ of offspring.

The probability that a bird will survive from one year to the next is $s$.

a) Show that the number $n(\tau)=M(\tau)+F(\tau)$ of birds _not_ in a pair 
is governed by
$$\frac{dn}{d\tau}=-\frac{\sigma}{2}n^2, ~~~n(0)=N_t.$$

b) Using the above, show that the number $n(T)$ of birds that have not found a mate at the start of
the breeding season in year $t$ is
$$n(T)=\frac{r\,N_t}{r+2N_t}$$
where $N_t$ is the number of birds at the start of the season in that particular year and
where $r=4/(\sigma T)$.

c) Explain why the number of pairs $P(\tau)$ is governed by
$$\frac{dP}{d\tau}=-\frac12\frac{dn}{d\tau},~~~P(0)=0.$$

d) Use the above to show that the number of breeding pairs at the start of the
breeding season in year $t$ is 
$$P_t:=P(T)=\frac{N_t^2}{r+2N_t}.$$

e) Show that the population $N_{t+1}$ at the beginning of winter in year $t+1$ is given
by
$$
N_{t+1}=s\,N_t+\frac{c\,N_t^2}{r+2N_t+N_t^2/\delta}.
$$ {#eq-Nt}

f) Find the realistic steady states of the model in @eq-Nt for the case that
$$\frac{c}{1-s}-2\geq \sqrt{\frac{4r}{\delta}}.$$

g) Draw a cobweb diagram to illustrate the stability of the steady states in the case that there
are two positive steady states. Label key features of the curves.

h) What type of bifurcation occurs when there is equality in the condition in part f)?

:::

----------------------------------------------------------------------


::: {#exr-1.1}
#### Period-doubling and tangent bifurcations
Consider the discrete time model
$$
N_{t+1}=\frac{rN_t}{1+(N_t/K)^b}
$$ {#eq-ex_discrete_time}
where $r$, $b$ and $K$ are positive parameters with $b>1$. Show that
the model has two steady states. Investigate the stability of the
extinction steady state. Show that the non-trivial (non-zero) steady state can lose
stability through a period doubling bifurcation at $b=2r/(r-1)$, or a
tangent bifurcation at $r=1$. 
:::

----------------------------------------------------------------------



## Summary {.unnumbered}

This chapter introduced several key concepts in discrete-time population dynamics:

1. **Discrete vs Continuous Time**
   - Discrete models track populations at fixed time intervals
   - Useful for populations with seasonal reproduction
   - Can exhibit more complex dynamics than continuous models

2. **Key Models**
   - Discrete exponential: $N_{t+1} = RN_t$
   - Verhulst model: Shows logistic-type growth but can give negative populations
   - Ricker model: Prevents negative populations, used for salmon populations
   - Beverton-Holt model: Important in fisheries science

3. **Analysis Tools**
   - Fixed points found by solving $N^* = f(N^*)$
   - Linear analysis near fixed points: Stability when $|f'(N^*)|<1$
   - Cobweb diagrams visualize iteration dynamics

4. **Bifurcations**
   - Four types possible in discrete-time models:
     * Saddle-node (tangent)
     * Transcritical
     * Pitchfork
     * Period-doubling (unique to discrete-time models)
   - Period-doubling leads to oscillatory behavior

5. **Harvesting**
   - Can introduce critical depensation
   - Critical harvesting thresholds exist
   - Risk of population collapse near thresholds

**Key differences from continuous models:**

- Can exhibit more complex dynamics
- Period-doubling bifurcations possible
- Cobweb diagrams replace phase lines
- Solutions can oscillate or become chaotic
